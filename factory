#!/usr/bin/env python3

import os
import json
from pathlib import Path
import shutil
from tempfile import TemporaryDirectory
from subprocess import run, PIPE, check_call, check_output
from contextlib import contextmanager
from argparse import ArgumentParser, REMAINDER
import shlex

"""
reference:
* http://kitchen.ci
* https://github.com/esmil/kitchen-qemu
* https://help.ubuntu.com/community/UEC/Images#Ubuntu_Cloud_Guest_images_on_12.04_LTS_.28Precise.29_and_beyond_using_NoCloud
* http://ubuntu-smoser.blogspot.ro/2013/02/using-ubuntu-cloud-images-without-cloud.html
"""

repo = Path(__file__).resolve().parent
SHARED = repo / 'shared'
IMAGES = repo / 'images'
VAR = repo / 'var'
QEMU_HACKED_ARM = repo / 'qemu-hacked-arm'


def get_arch():
    return check_output(['uname', '-m']).decode('latin1').strip()

def echo_run(cmd):
    print('+', *cmd)
    run(cmd, check=True)

@contextmanager
def cd(path):
    prev = os.getcwd()
    os.chdir(str(path))
    try:
        yield
    finally:
        os.chdir(prev)

@contextmanager
def instance(platform, shares, memory):
    platform_home = IMAGES / platform

    def _share(s):
        (path, mountpoint) = s.split(':')
        return {
            'path': str(Path(path).resolve()),
            'mountpoint': mountpoint,
        }

    platform = {
        'name': 'factory',
        'driver': {
            'image': str(platform_home / 'disk.img'),
            'memory': memory,
            'username': 'ubuntu',
            'password': 'ubuntu',
            'hostshares': [_share(s) for s in shares],
        },
    }

    if get_arch() == 'aarch64':
        platform['driver']['bios'] = str(platform_home / 'arm-bios.fd')
        platform['driver']['binary'] = str(QEMU_HACKED_ARM)

    kitchen_yml = {
        'driver': {'name': 'qemu'},
        'platforms': [platform],
        'suites': [{'name': 'vm'}],
    }

    if not VAR.is_dir():
        VAR.mkdir()

    with TemporaryDirectory(prefix='kitchen-', dir=str(VAR)) as tmp_name:
        tmp = Path(tmp_name)
        with (tmp / '.kitchen.yml').open('w', encoding='utf8') as f:
            print(json.dumps(kitchen_yml, indent=2), file=f)

        with cd(tmp):
            try:
                echo_run(['kitchen', 'create'])
                yield
            finally:
                echo_run(['kitchen', 'destroy'])

def run_factory(platform, *args):
    parser = ArgumentParser()
    parser.add_argument('--share', action='append', default=[])
    parser.add_argument('-m', '--memory', default=512, type=int)
    parser.add_argument('args', nargs=REMAINDER)
    options = parser.parse_args(args)

    with instance(platform, options.share, options.memory):
        args = ['sudo'] + options.args
        cmd = ' '.join(shlex.quote(a) for a in args)
        echo_run(['kitchen', 'exec', '-c', cmd])

def login(platform, *args):
    parser = ArgumentParser()
    parser.add_argument('--share', action='append', default=[])
    parser.add_argument('-m', '--memory', default=512, type=int)
    options = parser.parse_args(args)
    with instance(platform, options.share, options.memory):
        echo_run(['kitchen', 'login'])

CLOUD_INIT_YML = """\
#cloud-config
password: ubuntu
chpasswd: { expire: False }
ssh_pwauth: True
runcmd:
  - "dd if=/dev/zero of=/var/local/swap1 bs=1M count=2048"
  - "mkswap /var/local/swap1"
  - "echo '/var/local/swap1 none swap sw 0 0' >> /etc/fstab"
  - "touch /etc/cloud/cloud-init.disabled"
  - "systemctl disable apt-daily.service"
  - "systemctl disable apt-daily.timer"
  - "poweroff"
"""

class BaseBuilder:

    base_image_url = None

    def __init__(self, images):
        self.images = images
        self.disk_img_orig = images / 'disk.img.orig'
        self.disk_img_dist = images / 'disk.img.dist'
        self.disk_img = images / 'disk.img'

    def download(self):
        self.images.mkdir(exist_ok=True)
        if not self.disk_img_orig.is_file():
            check_call([
                'wget', str(self.base_image_url),
                '-O', str(self.disk_img_dist),
                '-q'
            ])
            check_call([
                'qemu-img', 'convert',
                '-O', 'qcow2',
                str(self.disk_img_dist),
                str(self.disk_img_orig),
            ])

    def prepare_disk_image(self):
        if self.disk_img.is_file():
            self.disk_img.unlink()

        check_call([
            'qemu-img', 'create',
            '-f', 'qcow2',
            '-b', str(self.disk_img_orig),
            str(self.disk_img),
        ])
        check_call([
            'qemu-img', 'resize',
            str(self.disk_img),
            '10G',
        ])

    def create_cloud_init_image(self):
        cloud_init_yml = self.images / 'cloud-init.yml'
        self.cloud_init_img = self.images / 'cloud-init.img'
        with cloud_init_yml.open('w', encoding='utf8') as f:
            f.write(CLOUD_INIT_YML)

        check_call([
            'cloud-localds',
            str(self.cloud_init_img),
            str(cloud_init_yml),
        ])

    def build(self):
        self.download()
        self.prepare_disk_image()
        self.create_cloud_init_image()
        self.run_qemu()


class Builder_x86_64(BaseBuilder):

    base_image_url = (
        'https://cloud-images.ubuntu.com/server/releases/16.04/release/'
        'ubuntu-16.04-server-cloudimg-amd64-disk1.img'
    )

    def run_qemu(self):
        check_call([
            'qemu-system-x86_64',
            '-enable-kvm',
            '-nographic',
            '-m', '512',
            '-netdev', 'user,id=user',
            '-device', 'virtio-net-pci,netdev=user',
            '-drive', 'index=0,media=disk,file=' + str(self.disk_img),
            '-drive', 'index=1,media=disk,format=raw,file='
                + str(self.cloud_init_img),
        ])


class Builder_arm64(BaseBuilder):

    base_image_url = (
        'https://cloud-images.ubuntu.com/server/releases/16.04/release/'
        'ubuntu-16.04-server-cloudimg-arm64-uefi1.img'
    )

    bios_url = (
        'https://releases.linaro.org/components/kernel/uefi-linaro/15.12/'
        'release/qemu64/QEMU_EFI.fd'
    )

    def __init__(self, images):
        super().__init__(images)
        self.arm_bios_fd = images / 'arm-bios.fd'

    def download(self):
        super().download()

        if not self.arm_bios_fd.is_file():
            check_call([
                'wget', '-q',
                str(self.bios_url),
                '-O', str(self.arm_bios_fd),
            ])

    def qemu_args(self):
        return [
            'qemu-system-aarch64',
            '-nographic',
            '-m', '512',
            '-machine', 'virt',
            '-bios', str(self.arm_bios_fd),
            '-netdev', 'user,id=user',
            '-device', 'virtio-net-pci,netdev=user,romfile=',
            '-device', 'virtio-blk-device,drive=image',
            '-drive', 'if=none,id=image,file=' + str(self.disk_img),
            '-device', 'virtio-blk-device,drive=cloud-init',
            '-drive', 'if=none,id=cloud-init,format=raw,file='
                + str(self.cloud_init_img),
        ]

    def run_qemu(self):
        check_call(self.qemu_args() + ['-cpu', 'host', '-enable-kvm'])

PLATFORMS = {
    'cloud-x86_64': Builder_x86_64,
    'cloud-arm64': Builder_arm64,
}

def prepare_cloud_image(platform):
    print("Preparing factory image for", platform)
    builder_cls = PLATFORMS[platform]

    images = Path(__file__).resolve().parent / 'images' / platform
    images.mkdir()
    try:
        builder_cls(images).build()
    except:
        shutil.rmtree(str(images))
        raise

COMMANDS = {
    'run': run_factory,
    'login': login,
    'prepare-cloud-image': prepare_cloud_image,
}

DEFAULTS = {
    'x86_64': 'cloud-x86_64',
    'aarch64': 'cloud-arm64',
}


def main():
    arch = get_arch()
    if arch in DEFAULTS.keys():
        default_platform = DEFAULTS[arch]
    else:
        raise RuntimeError("Architecture {} not supported.".format(arch))

    platform_list = [x.name for x in IMAGES.iterdir() if x.is_dir()]

    parser = ArgumentParser()
    parser.add_argument('--platform',
                        choices=platform_list,
                        default=default_platform)
    parser.add_argument('command', choices=COMMANDS.keys())
    (options, args) = parser.parse_known_args()
    COMMANDS[options.command](options.platform, *args)

if __name__ == '__main__':
    main()
